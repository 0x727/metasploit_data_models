require 'spec_helper'

describe Mdm::ExploitAttempt do
  subject(:exploit_attempt) do
    described_class.new
  end

  context 'associations' do
    it { should belong_to(:host).class_name('Mdm::Host') }
    it { should belong_to(:loot).class_name('Mdm::Loot') }
    it { should belong_to(:module_class).class_name('Mdm::Module::Class') }
    it { should belong_to(:service).class_name('Mdm::Service') }
    it { should belong_to(:session).class_name('Mdm::Session') }
    it { should belong_to(:vuln).class_name('Mdm::Vuln') }
  end

  context 'database' do

    context 'timestamps'do
      it { should have_db_column(:attempted_at).of_type(:datetime) }
    end

    context 'columns' do
      it { should have_db_column(:exploited).of_type(:boolean) }
      it { should have_db_column(:fail_detail).of_type(:text) }
      it { should have_db_column(:fail_reason).of_type(:string) }
      it { should have_db_column(:host_id).of_type(:integer) }
      it { should have_db_column(:loot_id).of_type(:integer) }
      it { should have_db_column(:module).of_type(:text) }
      it { should have_db_column(:module_class_id).of_type(:integer) }
      it { should have_db_column(:port).of_type(:integer) }
      it { should have_db_column(:proto).of_type(:string) }
      it { should have_db_column(:service_id).of_type(:integer) }
      it { should have_db_column(:session_id).of_type(:integer) }
      it { should have_db_column(:username).of_type(:string) }
      it { should have_db_column(:vuln_id).of_type(:integer) }
    end

    context 'indices' do
      it { should have_db_index(:module_class_id) }
    end
  end

  context '#destroy' do
    it 'should successfully destroy the object and all dependent objects' do
      exploit_attempt = FactoryGirl.create(:mdm_exploit_attempt)
      expect {
        exploit_attempt.destroy
      }.to_not raise_error
      expect {
        exploit_attempt.reload
      }.to raise_error(ActiveRecord::RecordNotFound)

    end
  end

  context 'validations' do
    it 'should only be valid with a host_id' do
      orphaned_attempt = FactoryGirl.build(:mdm_exploit_attempt, :host => nil)
      orphaned_attempt.should_not be_valid
      orphaned_attempt.errors[:host_id].should include("can't be blank")
      propper_attempt = FactoryGirl.build(:mdm_exploit_attempt)
      propper_attempt.should be_valid
    end
  end

  context 'factory' do
    it 'should be valid' do
      exploit_attempt = FactoryGirl.build(:mdm_exploit_attempt)
      exploit_attempt.should be_valid
    end
  end

  context '#module' do
    subject(:exploit_attempt_module) do
      exploit_attempt.module
    end

    it 'is deprecated' do
      expect(ActiveSupport::Deprecation).to receive(:warn).with(/Mdm::ExploitAttempt#module is deprecated/)

      exploit_attempt_module
    end

    context 'with attribute set' do
      #
      # lets
      #

      let(:expected) do
        'module/class/full/name'
      end

      #
      # Callbacks
      #

      before(:each) do
        exploit_attempt.module = expected
      end

      it 'reads attribute' do
        expect(exploit_attempt_module).to eq(expected)
      end
    end
  end

  context '#module=' do
    subject(:written_module) do
      exploit_attempt.module = full_name
    end

    let(:full_name) do
      'module/class/full/name'
    end

    it 'is deprecated' do
      expect(ActiveSupport::Deprecation).to receive(:warn).with(/Mdm::ExploitAttempt#module= is deprecated/)

      written_module
    end

    it 'can be read back with #module' do
      written_module

      expect(exploit_attempt.module).to eq(full_name)
    end
  end

  context '#port' do
    subject(:port) do
      exploit_attempt.port
    end

    it 'is deprecated' do
      expect(ActiveSupport::Deprecation).to receive(:warn).with(/Mdm::ExploitAttempt#port is deprecated/)

      port
    end

    context 'with attribute set' do
      #
      # lets
      #

      let(:expected) do
        22
      end

      #
      # Callbacks
      #

      before(:each) do
        exploit_attempt.port = expected
      end

      it 'reads attribute' do
        expect(port).to eq(expected)
      end
    end
  end

  context '#port=' do
    subject(:written_port) do
      exploit_attempt.port = port
    end

    let(:port) do
      22
    end

    it 'is deprecated' do
      expect(ActiveSupport::Deprecation).to receive(:warn).with(/Mdm::ExploitAttempt#port= is deprecated/)

      written_port
    end

    it 'can be read back with #port' do
      written_port

      expect(exploit_attempt.port).to eq(port)
    end
  end

  context '#proto' do
    subject(:proto) do
      exploit_attempt.proto
    end

    it 'is deprecated' do
      expect(ActiveSupport::Deprecation).to receive(:warn).with(/Mdm::ExploitAttempt#proto is deprecated/)

      proto
    end

    context 'with attribute set' do
      #
      # lets
      #

      let(:expected) do
        22
      end

      #
      # Callbacks
      #

      before(:each) do
        exploit_attempt.proto = expected
      end

      it 'reads attribute' do
        expect(proto).to eq(expected)
      end
    end
  end

  context '#proto=' do
    subject(:written_proto) do
      exploit_attempt.proto = proto
    end

    let(:proto) do
      22
    end

    it 'is deprecated' do
      expect(ActiveSupport::Deprecation).to receive(:warn).with(/Mdm::ExploitAttempt#proto= is deprecated/)

      written_proto
    end

    it 'can be read back with #proto' do
      written_proto

      expect(exploit_attempt.proto).to eq(proto)
    end
  end
end