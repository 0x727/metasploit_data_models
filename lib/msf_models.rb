require "active_record"
require "active_support"
require "active_support/all"
require "shellwords"

require "msf_models/version"
require "msf_models/serialized_prefs"
require "msf_models/base64_serializer"
require "msf_models/db_manager/db_objects"

require "msf_models/validators/ip_format_validator"


# Declare the common namespace we'll use in both MSF and Pro
module Msm; end

module MsfModels
  module ActiveRecordModels; end

  # Dynamically create AR classes if being included from Msf::DBManager
  # otherwise, just make the modules available for arbitrary inclusion.
  def self.included(base)
    ar_mixins.each{|file| require file}
    create_and_load_ar_classes if base == Msf::DBManager
  end

  # The code in each of these represents the basic structure of a correspondingly named
  # ActiveRecord model class.  Those classes are explicitly declared in
  # Rails and are dynamically generated by create_and_load_ar_classes
  # for MSF.
  def self.ar_mixins
    models_dir = File.expand_path(File.dirname(__FILE__)) + "/msf_models/active_record_models"
    Dir.glob("#{models_dir}/*.rb")
  end

  # (MSF-only) Dynamically create ActiveRecord descendant classes
  # and load them into the namespace provided by base
  def self.create_and_load_ar_classes
    ar_module_names.each do |cname|
      class_str =<<-RUBY
        class Msm::#{cname} < ActiveRecord::Base
          include MsfModels::ActiveRecordModels::#{cname}
        end
      RUBY
      eval class_str, binding, __FILE__, __LINE__
    end
  end

  # Derive "constant" strings from the names of the files in
  # lib/msf_models/active_record_models
  def self.ar_module_names
    ar_mixins.inject([]) do |array, path|
      filename = File.basename(path).split(".").first
      c_name = filename.classify
      c_name << "s" if filename =~ /^[\w]+s$/
      array << c_name
      array
    end
  end

end
