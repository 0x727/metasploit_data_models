# A set of {#matches automatic exploitation matches}.
class MetasploitDataModels::AutomaticExploitation::MatchSet < ActiveRecord::Base
  #
  # Associations
  #

  # Runs of this set of {#matches}.
  has_many :runs,
           class_name: "MetasploitDataModels::AutomaticExploitation::Run",
           inverse_of: :match_set

  # Matches in this set.
  has_many :matches,
           class_name: "MetasploitDataModels::AutomaticExploitation::Match",
           inverse_of: :match_set,
           dependent: :destroy

  # User that created this match set.
  belongs_to :user,
             inverse_of: :automatic_exploitation_match_sets,
             class_name: "Mdm::User"

  # Workspace in which this match set exists.
  belongs_to :workspace,
             inverse_of: :automatic_exploitation_match_sets,
             class_name: "Mdm::Workspace"

  #
  # Validations
  #

  validates :user,
            presence: true

  validates :workspace,
            presence: true


  # Create a Match object for a given Mdm::Vuln
  # working with associated ::Nexpose::Data::Exploit objects to find a specific Mdm::Module::Detail
  # Filter to exclude "passive" stance.
  #
  # @param[Mdm::Vuln] the Vuln we want to create a match for
  # @param[Hash] args further arguments used to make the Match
  # @option args [String] :module_fullname the Mdm::Module::Detail we want to create a match for
  #
  # @return[Metasploit::Data::Models::AutomaticExploitation::Match]
  def create_match_for_vuln(vuln,args={})
    match_set = self

    transaction do
      return unless vuln.nexpose_vulnerability_definition.present?
      runnable_exploits = vuln.nexpose_vulnerability_definition.exploits.metasploit_exploits

      return unless runnable_exploits.present?
      runnable_exploits.each do |exploit|
        module_detail = exploit.corresponding_mdm_record

        if exploit.present? && module_detail.aggressive? && args[:module_fullname] == module_detail.fullname
          match = match_set.matches.build({
                                            matchable:               vuln,
                                            module_fullname:         module_detail.fullname,
                                            nexpose_data_exploit_id: exploit.id,
                                          })
          match_set.save
          return match
        else
          next # There's no aggressive-stance Metasploit-sourced exploit in this record, so we move on
        end
      end

    end
  end


  Metasploit::Concern.run(self)
end
